<!-- 1) Load Supabase config first (must exist!) -->
<script src="/games/dnd/supabase-config.js"></script>

<!-- 2) Game code -->
<script src="/games/dnd/dnd.js"></script>

<!-- 3) Supabase client (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>

<!-- 4) Leaderboard logic -->
<script>
(() => {
  // === Supabase config ===
  const SUPABASE_URL = window.SUPABASE_URL;
  const SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY;

  // If config file is missing or keys not set, fail loudly and keep UI usable.
  if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
    console.warn("[Supabase] Missing config. Ensure /games/dnd/supabase-config.js is loaded and sets window.SUPABASE_URL + window.SUPABASE_ANON_KEY.");
    // Optional: show something in the leaderboard area instead of infinite loading
    const hsListEl = document.getElementById("hsList");
    if (hsListEl) hsListEl.innerHTML = '<li style="opacity:.75;">Leaderboard offline (saknar Supabase-config).</li>';
    return;
  }

  // Your table or view name:
  // - If you created the view: "top10_scores" (recommended)
  // - Otherwise: "scores"
  const TOP_SOURCE = "top10_scores";
  const TABLE_INSERT = "scores";

  const HS_MAX = 10;

  // Local caches (UX): avoids empty leaderboard/high=0 flashes on refresh.
  const LS_LATEST = "dnd.latestAttempt.v1";
  const LS_PLAYER = "dnd.playerName.v1";
  const LS_TOPCACHE = "dnd.top10.cache.v1";

  const hsListEl = document.getElementById("hsList");
  const highEl = document.getElementById("high");
  const latestScoreEl = document.getElementById("latestScore");

  const nameEntryEl = document.getElementById("nameEntry");
  const nameFormEl = document.getElementById("nameForm");
  const playerNameEl = document.getElementById("playerName");
  const nameHintEl = document.getElementById("nameHint");

  let client = null;
  let cachedTop = [];
  let pendingScore = null;

  function parseIntSafe(s) {
    const n = parseInt(String(s).replace(/[^0-9-]/g, ""), 10);
    return Number.isFinite(n) ? n : 0;
  }

  function setLatest(score) {
    localStorage.setItem(LS_LATEST, String(score));
    if (latestScoreEl) latestScoreEl.textContent = String(score);
  }

  function renderLatestFromStorage() {
    const v = localStorage.getItem(LS_LATEST);
    if (latestScoreEl) latestScoreEl.textContent = v ? v : "â€”";
  }

  function loadTopCache() {
    try {
      const raw = localStorage.getItem(LS_TOPCACHE);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return [];
      return arr
        .map(r => ({ name: String(r?.name ?? "Anon").slice(0, 12), score: Number(r?.score ?? 0) || 0 }))
        .filter(r => r.score >= 0)
        .slice(0, HS_MAX);
    } catch {
      return [];
    }
  }

  function saveTopCache(list) {
    try { localStorage.setItem(LS_TOPCACHE, JSON.stringify(list.slice(0, HS_MAX))); } catch {}
  }

  function renderTop(list, { loading = false } = {}) {
    if (!hsListEl) return;

    if (!list.length && loading) {
      hsListEl.innerHTML = '<li style="opacity:.75;">Laddar topplistanâ€¦</li>';
      return;
    }

    // Keep existing list if we have no new data (e.g. fetch failed).
    if (!list.length && hsListEl.children.length) return;

    hsListEl.innerHTML = "";
    list.slice(0, HS_MAX).forEach((row, i) => {
      const li = document.createElement("li");
      li.style.display = "flex";
      li.style.justifyContent = "space-between";
      li.style.gap = "12px";

      const left = document.createElement("span");
      left.textContent = `${i + 1}. ${row.name}`;

      const right = document.createElement("span");
      right.textContent = `${row.score} score`;

      li.appendChild(left);
      li.appendChild(right);
      hsListEl.appendChild(li);
    });

    if (highEl && list.length) highEl.textContent = String(list[0].score);
  }

  function qualifies(score, list) {
    if (score <= 0) return false;
    if (list.length < HS_MAX) return true;
    const last = list[list.length - 1]?.score ?? 0;
    return score > last;
  }

  function showNameEntry(score) {
    pendingScore = score;
    if (!nameEntryEl) return;

    if (nameHintEl) {
      nameHintEl.style.display = "none";
      nameHintEl.textContent = "";
    }

    nameEntryEl.style.display = "block";

    const savedName = localStorage.getItem(LS_PLAYER) || "";
    if (playerNameEl) {
      playerNameEl.value = savedName;
      setTimeout(() => playerNameEl.focus(), 0);
      setTimeout(() => playerNameEl.select(), 0);
    }
  }

  function hideNameEntry() {
    pendingScore = null;
    if (nameEntryEl) nameEntryEl.style.display = "none";
  }

  function normalizeName(name) {
    const n = String(name ?? "").trim().slice(0, 12);
    return n.length ? n : "Anon";
  }

  async function fetchTop10() {
    if (!client) return null;

    try {
      if (TOP_SOURCE === "top10_scores") {
        const { data, error } = await client.from("top10_scores").select("name,score,created_at");
        if (error) throw error;
        return (data || []).map(r => ({ name: String(r.name), score: Number(r.score) || 0 }));
      } else {
        const { data, error } = await client
          .from("scores")
          .select("name,score,created_at")
          .order("score", { ascending: false })
          .order("created_at", { ascending: true })
          .limit(HS_MAX);
        if (error) throw error;
        return (data || []).map(r => ({ name: String(r.name), score: Number(r.score) || 0 }));
      }
    } catch (e) {
      console.warn("[Supabase] fetchTop10 failed:", e);
      return null;
    }
  }

  async function refreshTop({ showLoading = false } = {}) {
    if (showLoading) renderTop(cachedTop, { loading: true });

    const fresh = await fetchTop10();
    if (fresh && fresh.length) {
      cachedTop = fresh;
      saveTopCache(cachedTop);
      renderTop(cachedTop);
    } else if (fresh && fresh.length === 0) {
      if (!cachedTop.length) {
        cachedTop = [];
        saveTopCache([]);
        if (hsListEl) hsListEl.innerHTML = '<li style="opacity:.75;">Ingen score Ã¤nnu. Bli den fÃ¶rsta. ðŸ˜ˆ</li>';
        if (highEl) highEl.textContent = "0";
      }
    } else {
      // keep cache
    }
  }

  async function submitScore(name, score) {
    if (!client) return false;

    const safeName = normalizeName(name);
    const safeScore = Math.max(0, parseIntSafe(score));

    try {
      const { error } = await client.from(TABLE_INSERT).insert([{ name: safeName, score: safeScore }]);
      if (error) throw error;
      localStorage.setItem(LS_PLAYER, safeName);
      return true;
    } catch (e) {
      console.warn("[Supabase] submitScore failed:", e);
      if (nameHintEl) {
        nameHintEl.textContent = "Kunde inte spara. Dubbelkolla RLS policies + att name/score Ã¤r inom grÃ¤nserna.";
        nameHintEl.style.display = "block";
      }
      return false;
    }
  }

  async function onGameOver(detail) {
    const finalScore = Math.max(0, parseIntSafe(detail?.score ?? 0));
    setLatest(finalScore);
    await refreshTop();
    if (qualifies(finalScore, cachedTop)) showNameEntry(finalScore);
    else hideNameEntry();
  }

  window.addEventListener("dnd:gameover", (e) => onGameOver(e.detail));

  if (nameFormEl) {
    nameFormEl.addEventListener("submit", async (e) => {
      e.preventDefault();
      if (pendingScore == null) return;

      const btn = nameFormEl.querySelector("button[type='submit']");
      if (btn) { btn.disabled = true; btn.textContent = "Spararâ€¦"; }

      const ok = await submitScore(playerNameEl?.value, pendingScore);

      if (btn) { btn.disabled = false; btn.textContent = "Spara"; }

      if (ok) {
        hideNameEntry();
        await refreshTop({ showLoading: true });
      }
    });
  }

  // Init
  renderLatestFromStorage();

  cachedTop = loadTopCache();
  if (cachedTop.length) renderTop(cachedTop);
  else renderTop([], { loading: true });

  // Wait until supabase UMD is actually available
  const initClient = () => {
    if (window.supabase?.createClient) {
      client = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      refreshTop({ showLoading: true });
    } else {
      setTimeout(initClient, 50);
    }
  };
  initClient();
})();
</script>
